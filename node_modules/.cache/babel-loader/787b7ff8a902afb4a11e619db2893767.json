{"ast":null,"code":"/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = require('buffer').Buffer;\n\nvar _ = require('underscore');\n\nvar utils = require('web3-utils');\n\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\n\nvar ParamType = require('@ethersproject/abi').ParamType;\n\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\n\n\nvar ABICoder = function ABICoder() {};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\n\n\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\n\n\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\n\n\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\n\n\nABICoder.prototype.encodeParameters = function (types, params) {\n  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n  var paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n  var paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n  params = params.map(function (param, index) {\n    var type = types[index];\n\n    if (typeof type === 'object' && type.type) {\n      // We may get a named type of shape {name, type}\n      type = type.type;\n    } // Format BN to string\n\n\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n      return param.toString(10);\n    } // Handle some formatting of params for backwards compatability with Ethers V4\n\n\n    var formatParam = function formatParam(type, param) {\n      if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(function (p) {\n          return formatParam(type.replace('[]', ''), p);\n        });\n      } // Format correct width for u?int[0-9]*\n\n\n      var match = type.match(paramTypeNumber);\n\n      if (match) {\n        var size = parseInt(match[2] || \"256\");\n\n        if (size / 8 < param.length) {\n          // pad to correct bit width\n          param = utils.leftPad(param, size);\n        }\n      } // Format correct length for bytes[0-9]+\n\n\n      match = type.match(paramTypeBytes);\n\n      if (match) {\n        if (Buffer.isBuffer(param)) {\n          param = utils.toHex(param);\n        } // format to correct length\n\n\n        var _size = parseInt(match[1]);\n\n        if (_size) {\n          var maxSize = _size * 2;\n\n          if (param.substring(0, 2) === '0x') {\n            maxSize += 2;\n          }\n\n          if (param.length < maxSize) {\n            // pad to correct length\n            param = utils.rightPad(param, _size * 2);\n          }\n        } // format odd-length bytes to even-length\n\n\n        if (param.length % 2 === 1) {\n          param = '0x0' + param.substring(2);\n        }\n      }\n\n      return param;\n    };\n\n    param = formatParam(type, param); // Format tuples for above rules\n\n    if (typeof type === 'string' && type.includes('tuple')) {\n      var _coder = ethersAbiCoder._getCoder(ParamType.from(type));\n\n      var modifyParams = function modifyParams(coder, param) {\n        coder.coders.forEach(function (c, i) {\n          if (c.name === 'tuple') {\n            modifyParams(c, param[i]);\n          } else {\n            param[i] = formatParam(c.name, param[i]);\n          }\n        });\n      };\n\n      modifyParams(_coder, param);\n    }\n\n    return param;\n  });\n  return ethersAbiCoder.encode(this.mapTypes(types), params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\n\n\nABICoder.prototype.mapTypes = function (types) {\n  var self = this;\n  var mappedTypes = [];\n  types.forEach(function (type) {\n    if (self.isSimplifiedStructFormat(type)) {\n      var structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\n\n\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\n\n\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  var type = 'tuple';\n\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n\n  return {\n    type: type,\n    name: structName\n  };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\n\n\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  var self = this;\n  var components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\n\n\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\n\n\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n  }\n\n  var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = res[returnValue.__length__];\n    decodedValue = decodedValue === '0x' ? null : decodedValue;\n    returnValue[i] = decodedValue;\n\n    if (_.isObject(output) && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  var _this = this;\n\n  topics = _.isArray(topics) ? topics : [topics];\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedParams = [];\n  var topicCount = 0; // TODO check for anonymous logs?\n\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data;\n  var notIndexedParams = nonIndexedData ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\nvar coder = new ABICoder();\nmodule.exports = coder;","map":{"version":3,"sources":["/Users/zaralaila/Desktop/sijil/node_modules/web3-eth-abi/src/index.js"],"names":["Buffer","require","_","utils","EthersAbiCoder","AbiCoder","ParamType","ethersAbiCoder","type","value","match","isArray","isObject","constructor","name","toString","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","types","params","paramTypeBytes","RegExp","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","map","index","isBN","isBigNumber","formatParam","p","replace","size","parseInt","length","leftPad","isBuffer","toHex","maxSize","substring","rightPad","includes","coder","_getCoder","from","modifyParams","coders","forEach","c","i","encode","mapTypes","self","mappedTypes","isSimplifiedStructFormat","structName","Object","keys","push","assign","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","encodeFunctionCall","jsonInterface","inputs","decodeParameter","bytes","decodeParameters","outputs","Error","res","decode","returnValue","__length__","output","decodedValue","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","module","exports"],"mappings":"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","sourcesContent":["/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\n\nvar Buffer = require('buffer').Buffer;\nvar _ = require('underscore');\nvar utils = require('web3-utils');\n\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\nvar ParamType = require('@ethersproject/abi').ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n\n// result method\nfunction Result() {\n}\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName).slice(0, 10);\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName);\n};\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n\n    params = params.map(function (param, index) {\n        let type = types[index]\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type\n        }\n\n        // Format BN to string\n        if (utils.isBN(param) || utils.isBigNumber(param)) {\n            return param.toString(10);\n        }\n\n        // Handle some formatting of params for backwards compatability with Ethers V4\n        const formatParam = (type, param) => {\n            if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n                return param.map(p => formatParam(type.replace('[]', ''), p))\n            }\n\n            // Format correct width for u?int[0-9]*\n            let match = type.match(paramTypeNumber);\n            if (match) {\n                let size = parseInt(match[2] || \"256\");\n                if (size / 8 < param.length) {\n                    // pad to correct bit width\n                    param = utils.leftPad(param, size);\n                }\n            }\n\n            // Format correct length for bytes[0-9]+\n            match = type.match(paramTypeBytes);\n            if (match) {\n                if (Buffer.isBuffer(param)) {\n                    param = utils.toHex(param);\n                }\n\n                // format to correct length\n                let size = parseInt(match[1]);\n                if (size) {\n                    let maxSize = size * 2;\n                    if (param.substring(0, 2) === '0x') {\n                        maxSize += 2;\n                    }\n                    if (param.length < maxSize) {\n                        // pad to correct length\n                        param = utils.rightPad(param, size * 2)\n                    }\n                }\n                \n                // format odd-length bytes to even-length\n                if (param.length % 2 === 1) { \n                    param = '0x0' + param.substring(2)\n                }\n            }\n\n            return param\n        }\n\n        param = formatParam(type, param)\n\n        // Format tuples for above rules\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i])\n                    } else {\n                        param[i] = formatParam(c.name, param[i])\n                    }\n                })\n            }\n            modifyParams(coder, param)\n        }\n\n        return param;\n    })\n    return ethersAbiCoder.encode(this.mapTypes(types), params);\n};\n\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(\n                Object.assign(\n                    self.mapStructNameAndType(structName),\n                    {\n                        components: self.mapStructToCoderFormat(type[structName])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        mappedTypes.push(type);\n    });\n\n    return mappedTypes;\n};\n\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n\n    return {type: type, name: structName};\n};\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(\n                Object.assign(\n                    self.mapStructNameAndType(key),\n                    {\n                        components: self.mapStructToCoderFormat(struct[key])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n\n    return components;\n};\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error(\n            'Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.'\n        );\n    }\n\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n\n        returnValue[i] = decodedValue;\n\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = _.isArray(topics) ? topics : [topics];\n\n    data = data || '';\n\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n\n    // TODO check for anonymous logs?\n\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        } else {\n            notIndexedInputs[i] = input;\n        }\n    });\n\n\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\nvar coder = new ABICoder();\n\nmodule.exports = coder;\n"]},"metadata":{},"sourceType":"script"}