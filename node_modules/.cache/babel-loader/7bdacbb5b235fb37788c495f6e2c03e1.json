{"ast":null,"code":"\"use strict\";\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardles.\n *\n */\n\nimport _classCallCheck from \"/Users/zaralaila/Desktop/sijil/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/zaralaila/Desktop/sijil/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BN } from \"bn.js\";\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar _constructorGuard = {};\nvar MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n  return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === \"bigint\" || isBytes(value));\n}\nexport var BigNumber = /*#__PURE__*/function () {\n  function BigNumber(constructorGuard, hex) {\n    _classCallCheck(this, BigNumber);\n\n    logger.checkNew(this instanceof BigNumber ? this.constructor : void 0, BigNumber);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new (BigNumber)\"\n      });\n    }\n\n    this._hex = hex;\n    this._isBigNumber = true;\n    Object.freeze(this);\n  }\n\n  _createClass(BigNumber, [{\n    key: \"fromTwos\",\n    value: function fromTwos(value) {\n      return toBigNumber(toBN(this).fromTwos(value));\n    }\n  }, {\n    key: \"toTwos\",\n    value: function toTwos(value) {\n      return toBigNumber(toBN(this).toTwos(value));\n    }\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      if (this._hex[0] === \"-\") {\n        return BigNumber.from(this._hex.substring(1));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return toBigNumber(toBN(this).add(toBN(other)));\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(other) {\n      return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n  }, {\n    key: \"div\",\n    value: function div(other) {\n      var o = BigNumber.from(other);\n\n      if (o.isZero()) {\n        throwFault(\"division by zero\", \"div\");\n      }\n\n      return toBigNumber(toBN(this).div(toBN(other)));\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(other) {\n      return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n  }, {\n    key: \"mod\",\n    value: function mod(other) {\n      var value = toBN(other);\n\n      if (value.isNeg()) {\n        throwFault(\"cannot modulo negative values\", \"mod\");\n      }\n\n      return toBigNumber(toBN(this).umod(value));\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(other) {\n      return toBigNumber(toBN(this).pow(toBN(other)));\n    }\n  }, {\n    key: \"and\",\n    value: function and(other) {\n      var value = toBN(other);\n\n      if (this.isNegative() || value.isNeg()) {\n        throwFault(\"cannot 'and' negative values\", \"and\");\n      }\n\n      return toBigNumber(toBN(this).and(value));\n    }\n  }, {\n    key: \"or\",\n    value: function or(other) {\n      var value = toBN(other);\n\n      if (this.isNegative() || value.isNeg()) {\n        throwFault(\"cannot 'or' negative values\", \"or\");\n      }\n\n      return toBigNumber(toBN(this).or(value));\n    }\n  }, {\n    key: \"xor\",\n    value: function xor(other) {\n      var value = toBN(other);\n\n      if (this.isNegative() || value.isNeg()) {\n        throwFault(\"cannot 'xor' negative values\", \"xor\");\n      }\n\n      return toBigNumber(toBN(this).xor(value));\n    }\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      if (this.isNegative() || value < 0) {\n        throwFault(\"cannot mask negative values\", \"mask\");\n      }\n\n      return toBigNumber(toBN(this).maskn(value));\n    }\n  }, {\n    key: \"shl\",\n    value: function shl(value) {\n      if (this.isNegative() || value < 0) {\n        throwFault(\"cannot shift negative values\", \"shl\");\n      }\n\n      return toBigNumber(toBN(this).shln(value));\n    }\n  }, {\n    key: \"shr\",\n    value: function shr(value) {\n      if (this.isNegative() || value < 0) {\n        throwFault(\"cannot shift negative values\", \"shr\");\n      }\n\n      return toBigNumber(toBN(this).shrn(value));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return toBN(this).eq(toBN(other));\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(other) {\n      return toBN(this).lt(toBN(other));\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(other) {\n      return toBN(this).lte(toBN(other));\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(other) {\n      return toBN(this).gt(toBN(other));\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(other) {\n      return toBN(this).gte(toBN(other));\n    }\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return this._hex[0] === \"-\";\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return toBN(this).isZero();\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      try {\n        return toBN(this).toNumber();\n      } catch (error) {\n        throwFault(\"overflow\", \"toNumber\", this.toString());\n      }\n\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // Lots of people expect this, which we do not support, so check\n      if (arguments.length !== 0) {\n        logger.throwError(\"bigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      }\n\n      return toBN(this).toString(10);\n    }\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return this._hex;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof BigNumber) {\n        return value;\n      }\n\n      if (typeof value === \"string\") {\n        if (value.match(/-?0x[0-9a-f]+/i)) {\n          return new BigNumber(_constructorGuard, toHex(value));\n        }\n\n        if (value.match(/^-?[0-9]+$/)) {\n          return new BigNumber(_constructorGuard, toHex(new BN(value)));\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n      }\n\n      if (typeof value === \"number\") {\n        if (value % 1) {\n          throwFault(\"underflow\", \"BigNumber.from\", value);\n        }\n\n        if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n          throwFault(\"overflow\", \"BigNumber.from\", value);\n        }\n\n        return BigNumber.from(String(value));\n      }\n\n      if (typeof value === \"bigint\") {\n        return BigNumber.from(value.toString());\n      }\n\n      if (isBytes(value)) {\n        return BigNumber.from(hexlify(value));\n      }\n\n      if (value._hex && isHexString(value._hex)) {\n        return BigNumber.from(value._hex);\n      }\n\n      if (value.toHexString) {\n        value = value.toHexString();\n\n        if (typeof value === \"string\") {\n          return BigNumber.from(value);\n        }\n      }\n\n      return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n  }, {\n    key: \"isBigNumber\",\n    value: function isBigNumber(value) {\n      return !!(value && value._isBigNumber);\n    }\n  }]);\n\n  return BigNumber;\n}(); // Normalize the hex string\n\nfunction toHex(value) {\n  // For BN, call on the hex string\n  if (typeof value !== \"string\") {\n    return toHex(value.toString(16));\n  } // If negative, prepend the negative sign to the normalized positive value\n\n\n  if (value[0] === \"-\") {\n    // Strip off the negative sign\n    value = value.substring(1); // Cannot have mulitple negative signs (e.g. \"--0x04\")\n\n    if (value[0] === \"-\") {\n      logger.throwArgumentError(\"invalid hex\", \"value\", value);\n    } // Call toHex on the positive component\n\n\n    value = toHex(value); // Do not allow \"-0x00\"\n\n    if (value === \"0x00\") {\n      return value;\n    } // Negate the value\n\n\n    return \"-\" + value;\n  } // Add a \"0x\" prefix if missing\n\n\n  if (value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  } // Normalize zero\n\n\n  if (value === \"0x\") {\n    return \"0x00\";\n  } // Make the string even length\n\n\n  if (value.length % 2) {\n    value = \"0x0\" + value.substring(2);\n  } // Trim to smallest even-length string\n\n\n  while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n    value = \"0x\" + value.substring(4);\n  }\n\n  return value;\n}\n\nfunction toBigNumber(value) {\n  return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value) {\n  var hex = BigNumber.from(value).toHexString();\n\n  if (hex[0] === \"-\") {\n    return new BN(\"-\" + hex.substring(3), 16);\n  }\n\n  return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault, operation, value) {\n  var params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value != null) {\n    params.value = value;\n  }\n\n  return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}","map":{"version":3,"sources":["/Users/zaralaila/Desktop/sijil/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"],"names":["BN","hexlify","isBytes","isHexString","Logger","version","logger","_constructorGuard","MAX_SAFE","isBigNumberish","value","BigNumber","isBigNumber","match","constructorGuard","hex","checkNew","throwError","errors","UNSUPPORTED_OPERATION","operation","_hex","_isBigNumber","Object","freeze","toBigNumber","toBN","fromTwos","toTwos","from","substring","other","add","sub","o","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","error","toString","arguments","length","UNEXPECTED_ARGUMENT","toHex","throwArgumentError","String","toHexString","fault","params","NUMERIC_FAULT"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardles.\n *\n */\nimport { BN } from \"bn.js\";\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof (value) === \"bigint\") ||\n        isBytes(value));\n}\nexport class BigNumber {\n    constructor(constructorGuard, hex) {\n        logger.checkNew(new.target, BigNumber);\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division by zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot modulo negative values\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        return toBigNumber(toBN(this).pow(toBN(other)));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'and' negative values\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'or' negative values\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'xor' negative values\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot mask negative values\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check\n        if (arguments.length !== 0) {\n            logger.throwError(\"bigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/-?0x[0-9a-f]+/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        if (typeof (value) === \"bigint\") {\n            return BigNumber.from(value.toString());\n        }\n        if (isBytes(value)) {\n            return BigNumber.from(hexlify(value));\n        }\n        if (value._hex && isHexString(value._hex)) {\n            return BigNumber.from(value._hex);\n        }\n        if (value.toHexString) {\n            value = value.toHexString();\n            if (typeof (value) === \"string\") {\n                return BigNumber.from(value);\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have mulitple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n"]},"metadata":{},"sourceType":"module"}