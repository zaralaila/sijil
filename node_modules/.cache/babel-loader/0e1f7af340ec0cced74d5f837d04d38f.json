{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/Users/zaralaila/Desktop/sijil/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/zaralaila/Desktop/sijil/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nvar _constructorGuard = {};\nvar Zero = BigNumber.from(0);\nvar NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message, fault, operation, value) {\n  var params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value !== undefined) {\n    params.value = value;\n  }\n\n  return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n} // Constant to pull zeros from for multipliers\n\n\nvar zeros = \"0\";\n\nwhile (zeros.length < 256) {\n  zeros += zeros;\n} // Returns a string \"1\" followed by decimal \"0\"s\n\n\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  var multiplier = getMultiplier(decimals); // Make sure wei is a big number (convert as necessary)\n\n  value = BigNumber.from(value);\n  var negative = value.lt(Zero);\n\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n\n  var fraction = value.mod(multiplier).toString();\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  } // Strip training 0\n\n\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  var whole = value.div(multiplier).toString();\n  value = whole + \".\" + fraction;\n\n  if (negative) {\n    value = \"-\" + value;\n  }\n\n  return value;\n}\nexport function parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  var multiplier = getMultiplier(decimals);\n\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  }\n\n  if (multiplier.length - 1 === 0) {\n    return BigNumber.from(value);\n  } // Is it negative?\n\n\n  var negative = value.substring(0, 1) === \"-\";\n\n  if (negative) {\n    value = value.substring(1);\n  }\n\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  } // Split it into a whole and fractional part\n\n\n  var comps = value.split(\".\");\n\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n\n  var whole = comps[0],\n      fraction = comps[1];\n\n  if (!whole) {\n    whole = \"0\";\n  }\n\n  if (!fraction) {\n    fraction = \"0\";\n  } // Prevent underflow\n\n\n  if (fraction.length > multiplier.length - 1) {\n    throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n  } // Fully pad the string with zeros to get to wei\n\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n\n  var wholeValue = BigNumber.from(whole);\n  var fractionValue = BigNumber.from(fraction);\n  var wei = wholeValue.mul(multiplier).add(fractionValue);\n\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n\n  return wei;\n}\nexport var FixedFormat = /*#__PURE__*/function () {\n  function FixedFormat(constructorGuard, signed, width, decimals) {\n    _classCallCheck(this, FixedFormat);\n\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n\n  _createClass(FixedFormat, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof FixedFormat) {\n        return value;\n      }\n\n      var signed = true;\n      var width = 128;\n      var decimals = 18;\n\n      if (typeof value === \"string\") {\n        if (value === \"fixed\") {// defaults...\n        } else if (value === \"ufixed\") {\n          signed = false;\n        } else if (value != null) {\n          var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\n          if (!match) {\n            logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n          }\n\n          signed = match[1] !== \"u\";\n          width = parseInt(match[2]);\n          decimals = parseInt(match[3]);\n        }\n      } else if (value) {\n        var check = function check(key, type, defaultValue) {\n          if (value[key] == null) {\n            return defaultValue;\n          }\n\n          if (typeof value[key] !== type) {\n            logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n          }\n\n          return value[key];\n        };\n\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n      }\n\n      if (width % 8) {\n        logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n      }\n\n      if (decimals > 80) {\n        logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n      }\n\n      return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n  }]);\n\n  return FixedFormat;\n}();\nexport var FixedNumber = /*#__PURE__*/function () {\n  function FixedNumber(constructorGuard, hex, value, format) {\n    _classCallCheck(this, FixedNumber);\n\n    logger.checkNew(this instanceof FixedNumber ? this.constructor : void 0, FixedNumber);\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n\n  _createClass(FixedNumber, [{\n    key: \"_checkFormat\",\n    value: function _checkFormat(other) {\n      if (this.format.name !== other.format.name) {\n        logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n      }\n    }\n  }, {\n    key: \"addUnsafe\",\n    value: function addUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"subUnsafe\",\n    value: function subUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"mulUnsafe\",\n    value: function mulUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"divUnsafe\",\n    value: function divUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    } // @TODO: Support other rounding algorithms\n\n  }, {\n    key: \"round\",\n    value: function round(decimals) {\n      if (decimals == null) {\n        decimals = 0;\n      }\n\n      if (decimals < 0 || decimals > 80 || decimals % 1) {\n        logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n      } // If we are already in range, we're done\n\n\n      var comps = this.toString().split(\".\");\n\n      if (comps[1].length <= decimals) {\n        return this;\n      } // Bump the value up by the 0.00...0005\n\n\n      var bump = \"0.\" + zeros.substring(0, decimals) + \"5\";\n      comps = this.addUnsafe(FixedNumber.fromString(bump, this.format))._value.split(\".\"); // Now it is safe to truncate\n\n      return FixedNumber.fromString(comps[0] + \".\" + comps[1].substring(0, decimals));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._value;\n    }\n  }, {\n    key: \"toHexString\",\n    value: function toHexString(width) {\n      if (width == null) {\n        return this._hex;\n      }\n\n      if (width % 8) {\n        logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n      }\n\n      var hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n      return hexZeroPad(hex, width / 8);\n    }\n  }, {\n    key: \"toUnsafeFloat\",\n    value: function toUnsafeFloat() {\n      return parseFloat(this.toString());\n    }\n  }, {\n    key: \"toFormat\",\n    value: function toFormat(format) {\n      return FixedNumber.fromString(this._value, format);\n    }\n  }], [{\n    key: \"fromValue\",\n    value: function fromValue(value, decimals, format) {\n      // If decimals looks more like a format, and there is no format, shift the parameters\n      if (format == null && decimals != null && !isBigNumberish(decimals)) {\n        format = decimals;\n        decimals = null;\n      }\n\n      if (decimals == null) {\n        decimals = 0;\n      }\n\n      if (format == null) {\n        format = \"fixed\";\n      }\n\n      return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, format) {\n      if (format == null) {\n        format = \"fixed\";\n      }\n\n      var fixedFormat = FixedFormat.from(format);\n      var numeric = parseFixed(value, fixedFormat.decimals);\n\n      if (!fixedFormat.signed && numeric.lt(Zero)) {\n        throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n      }\n\n      var hex = null;\n\n      if (fixedFormat.signed) {\n        hex = numeric.toTwos(fixedFormat.width).toHexString();\n      } else {\n        hex = numeric.toHexString();\n        hex = hexZeroPad(hex, fixedFormat.width / 8);\n      }\n\n      var decimal = formatFixed(numeric, fixedFormat.decimals);\n      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(value, format) {\n      if (format == null) {\n        format = \"fixed\";\n      }\n\n      var fixedFormat = FixedFormat.from(format);\n\n      if (arrayify(value).length > fixedFormat.width / 8) {\n        throw new Error(\"overflow\");\n      }\n\n      var numeric = BigNumber.from(value);\n\n      if (fixedFormat.signed) {\n        numeric = numeric.fromTwos(fixedFormat.width);\n      }\n\n      var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n      var decimal = formatFixed(numeric, fixedFormat.decimals);\n      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n  }, {\n    key: \"from\",\n    value: function from(value, format) {\n      if (typeof value === \"string\") {\n        return FixedNumber.fromString(value, format);\n      }\n\n      if (isBytes(value)) {\n        return FixedNumber.fromBytes(value, format);\n      }\n\n      try {\n        return FixedNumber.fromValue(value, 0, format);\n      } catch (error) {\n        // Allow NUMERIC_FAULT to bubble up\n        if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n          throw error;\n        }\n      }\n\n      return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n  }, {\n    key: \"isFixedNumber\",\n    value: function isFixedNumber(value) {\n      return !!(value && value._isFixedNumber);\n    }\n  }]);\n\n  return FixedNumber;\n}();","map":{"version":3,"sources":["/Users/zaralaila/Desktop/sijil/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"],"names":["arrayify","hexZeroPad","isBytes","Logger","version","logger","BigNumber","isBigNumberish","_constructorGuard","Zero","from","NegativeOne","throwFault","message","fault","operation","value","params","undefined","throwError","errors","NUMERIC_FAULT","zeros","length","getMultiplier","decimals","toNumber","e","substring","throwArgumentError","formatFixed","multiplier","negative","lt","mul","fraction","mod","toString","match","whole","div","parseFixed","comps","split","wholeValue","fractionValue","wei","add","FixedFormat","constructorGuard","signed","width","name","String","_multiplier","Object","freeze","parseInt","check","key","type","defaultValue","FixedNumber","hex","format","checkNew","_hex","_value","_isFixedNumber","other","_checkFormat","a","b","fromValue","sub","bump","addUnsafe","fromString","fromTwos","toTwos","toHexString","parseFloat","fixedFormat","numeric","decimal","Error","fromBytes","error","code","INVALID_ARGUMENT"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    value = whole + \".\" + fraction;\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nexport function parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    if (multiplier.length - 1 === 0) {\n        return BigNumber.from(value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Prevent underflow\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nexport class FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else if (value != null) {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nexport class FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        logger.checkNew(new.target, FixedNumber);\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        // If we are already in range, we're done\n        let comps = this.toString().split(\".\");\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        // Bump the value up by the 0.00...0005\n        const bump = \"0.\" + zeros.substring(0, decimals) + \"5\";\n        comps = this.addUnsafe(FixedNumber.fromString(bump, this.format))._value.split(\".\");\n        // Now it is safe to truncate\n        return FixedNumber.fromString(comps[0] + \".\" + comps[1].substring(0, decimals));\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}